import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import path = require('path');

export class BackendStack extends cdk.Stack {

  public appSyncApiUrl:string;

  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    //The DynamoDB table that cahces the pricing items
    const pricingTable = new cdk.aws_dynamodb.Table(this, 'TgwPricingScraper', {
      partitionKey: { name: 'pricing_id', type: cdk.aws_dynamodb.AttributeType.STRING },
      billingMode: cdk.aws_dynamodb.BillingMode.PAY_PER_REQUEST,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    //An S3 bucket called network-calculator-resources      
    const netcalcBucket = new cdk.aws_s3.Bucket(this, 'network-calculator-resources', {
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    //The TgwPricingScraper pricing scraper function
    const pricingScraper = new cdk.aws_lambda.Function(this, 'PricingScraper', {
      runtime: cdk.aws_lambda.Runtime.PYTHON_3_10,
      description: 'A Lambda function that populates the DDB table with the TGW prices for all regions, for the AWS Networking Costs Calculator',
      code: cdk.aws_lambda.Code.fromAsset(path.join(__dirname, 'functions/PricingScraper')),
      handler: 'index.lambda_handler',
      environment: {
        'pricing_table': pricingTable.tableName,
        'netcalc_bucket': netcalcBucket.bucketName
      },
      memorySize: 1024,
      timeout: cdk.Duration.seconds(600)
    });
    pricingTable.grantReadWriteData(pricingScraper);
    netcalcBucket.grantReadWrite(pricingScraper);
    pricingScraper.addToRolePolicy(new cdk.aws_iam.PolicyStatement({
      sid: 'AllPricingApi',
      actions: ["pricing:DescribeServices", "pricing:GetAttributeValues", "pricing:GetProducts"],
      resources: ["*"],
      effect: cdk.aws_iam.Effect.ALLOW,
    }));
    //Export the lambda function so that it can be called for the first time immediatly after first deployment
    new cdk.CfnOutput(this, 'pricingScraperLambda', {
      value: pricingScraper.functionArn,
      exportName: 'pricingScraperLambda',
    });

    //A scheduler to run the pricingScraper every 24 hours
    const scheduler = new cdk.aws_events.Rule(this, 'PricingScraperScheduler', {
      schedule: cdk.aws_events.Schedule.rate(cdk.Duration.hours(24)),
      description: 'A scheduler to run the TGW pricing scraper function every 24 hours',
      enabled: true,
      targets: [new cdk.aws_events_targets.LambdaFunction(pricingScraper)]
    });

    //Function that parses and processes the above generated tgw file
    const distinctPopScraper = new cdk.aws_lambda.Function(this, 'DistinctPopScraper', {
      runtime: cdk.aws_lambda.Runtime.PYTHON_3_10,
      description: 'A Lambda function that retreives the distict PoPs from the S3 file (generated by the above scraper function) - used by the AppSync Lambda Resolver',
      code: cdk.aws_lambda.Code.fromAsset(path.join(__dirname, 'functions/DistinctPopScraper')),
      handler: 'index.lambda_handler',
      environment: {
        'netcalc_bucket': netcalcBucket.bucketName,
      },
      memorySize: 512,
      timeout: cdk.Duration.seconds(5),
    });
    netcalcBucket.grantRead(distinctPopScraper);

    //The simple AppSync API
    const api = new cdk.aws_appsync.GraphqlApi(this, 'NetCalcApi', {
      name: 'NetCalcApi',
      schema: cdk.aws_appsync.SchemaFile.fromAsset(path.join(__dirname, 'graphql/schema.graphql')),
      authorizationConfig: {
        defaultAuthorization: {
          authorizationType: cdk.aws_appsync.AuthorizationType.IAM,
        },
      },
    });
    const distinctPopDataSource = api.addLambdaDataSource('PopScraperDataSource', distinctPopScraper);
    distinctPopDataSource.createResolver('LambdaResolver', {
      typeName: 'Query',
      fieldName: 'distinctPops',
      requestMappingTemplate: cdk.aws_appsync.MappingTemplate.lambdaRequest(),
      responseMappingTemplate: cdk.aws_appsync.MappingTemplate.lambdaResult(),
    });
    const pricintTableDataSource = api.addDynamoDbDataSource('PricingTableDataSource', pricingTable);
    pricintTableDataSource.createResolver('DDBResolver', {
      typeName: 'Query',
      fieldName: 'bulkPrices',
      requestMappingTemplate: cdk.aws_appsync.MappingTemplate.fromString(`
          #set($ids = [])
          #foreach($id in \${ctx.args.ids})
              #set($map = {})
              $util.qr($map.put("pricing_id", $util.dynamodb.toString($id)))
              $util.qr($ids.add($map))
          #end
          {
              "version" : "2018-05-29",
              "operation" : "BatchGetItem",
              "tables" : {
                  "${pricingTable.tableName}": {
                      "keys": $util.toJson($ids),
                      "consistentRead": true
                  }
              }
          }      
      `),
      responseMappingTemplate: cdk.aws_appsync.MappingTemplate.fromString(`
        $util.toJson($ctx.result.data.${pricingTable.tableName})
      `)
    });

    //Identity pool, to allow IAM access to the above bulkPrices API
    const identityPool = new cdk.aws_cognito.CfnIdentityPool(this, 'NetCalcIdentityPool', {
      allowUnauthenticatedIdentities: true,
    });
    const identityPoolId = identityPool.ref;
    //export the identity pool ID
    new cdk.CfnOutput(this, 'identityPoolId', {
      value: identityPool.ref,
      exportName: 'NetCalcIdentityPoolId',
    });
    //export the API URL
    new cdk.CfnOutput(this, 'apiUrl', {
      value: api.graphqlUrl,
      exportName: 'NetCalcApiUrl',
    });
    this.appSyncApiUrl = api.graphqlUrl;

    //policy to be assumed by the unuthenticated (and authenticated) role
    const apiPolicy = {
      AllowNetcalcAPI: new cdk.aws_iam.PolicyDocument({
        statements: [ new cdk.aws_iam.PolicyStatement({
          effect: cdk.aws_iam.Effect.ALLOW,
          resources: [
            api.arn + '/types/Query/fields/bulkPrices',
            api.arn + '/types/Query/fields/distinctPops'
          ],
          actions: [ 'appsync:GraphQL' ],
        }),
        ],
      }),
    };
    //the unauthenticated role
    const unauthRole = new cdk.aws_iam.Role(this, 'UnauthenticatedRole', {
      assumedBy: new cdk.aws_iam.WebIdentityPrincipal('cognito-identity.amazonaws.com')
        .withConditions({
          StringEquals: { 'cognito-identity.amazonaws.com:aud': identityPoolId },
          'ForAnyValue:StringLike': { 'cognito-identity.amazonaws.com:amr': 'unauthenticated' },
        }),
      inlinePolicies: apiPolicy,
    });
    //attach the policies
    new cdk.aws_cognito.CfnIdentityPoolRoleAttachment(this, 'identityPoolRoleattachement', {
      identityPoolId,
      roles: {
        unauthenticated: unauthRole.roleArn,
      },
    });

  }
}
